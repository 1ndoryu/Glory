// Assets/js/GloryModalForm.js

class GloryModalForm {
    constructor() {
        // Use event delegation on the body for forms added dynamically
        document.body.addEventListener('submit', this._handleModalFormSubmit.bind(this));
        // console.log('GloryModalForm Initialized');
    }

    async _handleModalFormSubmit(event) {
        // Check if the submitted form has the specific data attribute
        const form = event.target;
        if (!form.matches('[data-glory-modal-form]')) {
            return; // Not a modal form we should handle
        }

        event.preventDefault();
        const modalElement = form.closest('[data-glory-modal]');
        if (!modalElement) {
            console.error('GloryModalForm: Could not find parent modal element [data-glory-modal] for form:', form);
            // Optionally show a generic error if possible?
            return;
        }

        // Get AJAX details from the modal container's data attributes
        const actionUpdate = modalElement.dataset.actionUpdate;
        const targetFormId = modalElement.dataset.targetFormId; // Optional: ID of the form that opened the modal

        // Nonce should be included as a hidden field within the <form> itself,
        // generated by PHP (wp_nonce_field or similar).
        const nonceInput = form.querySelector('input[name="_ajax_nonce"]');

        if (!actionUpdate || !nonceInput || !nonceInput.value) {
            const errorMsg = 'Client configuration error: Missing action or nonce.';
            console.error(`GloryModalForm: ${errorMsg}`, {
                modal: modalElement.id,
                form: form.id,
                actionUpdate: actionUpdate,
                nonceFound: !!nonceInput?.value
            });
            // Show error message *inside* the modal
            if (window.GloryModalService) {
                 window.GloryModalService.showModalMessage(modalElement, 'failure', errorMsg);
            }
            return;
        }
        const nonce = nonceInput.value;

        // Gather form data
        const formData = new FormData(form);
        // Convert FormData to a plain object for GloryAjax, if needed
        const requestData = {};
        formData.forEach((value, key) => {
            // Handle potential multiple values for checkboxes/multi-selects if necessary
            if (requestData.hasOwnProperty(key)) {
                if (!Array.isArray(requestData[key])) {
                    requestData[key] = [requestData[key]];
                }
                requestData[key].push(value);
            } else {
                requestData[key] = value;
            }
        });
        // Nonce is already included via FormData if it's an input field

        this._showLoading(form, true);
        // Clear previous *internal* modal errors before submitting
        if (window.GloryModalService) {
            window.GloryModalService.hideModalMessage(modalElement);
        }


        try {
            if (typeof GloryAjax !== 'function') {
                throw new Error('GloryAjax function is not defined.');
            }

            const result = await GloryAjax(actionUpdate, requestData);

            if (result.success) {
                // 1. Close the current modal
                if (window.GloryModalService) {
                    window.GloryModalService.closeModal(modalElement);
                }

                // 2. Dispatch a success event with details
                const successEvent = new CustomEvent('glory.modalForm.success', {
                    bubbles: true, // Allow event to bubble up the DOM
                    detail: {
                        modalId: modalElement.id,
                        originalTargetId: targetFormId || null, // Pass the original form ID if available
                        responseData: result.data // Pass the data part of the AJAX response
                    }
                });
                document.dispatchEvent(successEvent);
                // console.log(`GloryModalForm: Dispatched glory.modalForm.success for modal ${modalElement.id}`, successEvent.detail);

                // 3. Optional: Reset the form inside the modal for future use
                form.reset();

            } else {
                // Show error message *inside* the modal
                const errorMessage = result.data?.message || result.message || 'An error occurred. Please try again.';
                if (window.GloryModalService) {
                     window.GloryModalService.showModalMessage(modalElement, 'failure', errorMessage);
                } else {
                    console.error("GloryModalForm: GloryModalService not available to show failure message.");
                }
            }
        } catch (error) {
            console.error('GloryModalForm: Error during AJAX submission:', error);
            const clientErrorMsg = 'A client-side error occurred during submission.';
            if (window.GloryModalService) {
                 window.GloryModalService.showModalMessage(modalElement, 'failure', clientErrorMsg);
            } else {
                alert(clientErrorMsg); // Fallback
            }
        } finally {
            // Ensure loading state is removed regardless of success/failure
            this._showLoading(form, false);
        }
    }

    // Utility: Show loading state on the modal form's submit button
    _showLoading(formElement, show = true) {
        const submitButton = formElement.querySelector('button[type="submit"], input[type="submit"]');
        if (!submitButton) return;

        if (show) {
            submitButton.disabled = true;
            // Store original text only if not already stored
            if (!submitButton.dataset.originalValue) {
                 submitButton.dataset.originalValue = submitButton.type === 'submit' ? submitButton.value : submitButton.textContent;
            }
            const waitText = submitButton.dataset.wait || 'Processing...';
            if (submitButton.type === 'submit') {
                submitButton.value = waitText;
            } else {
                submitButton.textContent = waitText;
            }
        } else {
            // Restore original text if it was stored
            if (submitButton.dataset.originalValue) {
                if (submitButton.type === 'submit') {
                    submitButton.value = submitButton.dataset.originalValue;
                } else {
                    submitButton.textContent = submitButton.dataset.originalValue;
                }
                 // Clean up the stored value
                 delete submitButton.dataset.originalValue;
            }
             submitButton.disabled = false;
        }
    }

    // NOTE: _showExternalFormMessage function has been REMOVED.
    // Its responsibility is now handled by the listener for 'glory.modalForm.success'
    // in the script managing the original form (e.g., GloryEmailSignup.js).
}

// Initialize on theme ready or equivalent event
document.addEventListener('themePageReady', () => {
    // Check dependencies
    if (typeof GloryAjax === 'function' && typeof window.GloryModalService !== 'undefined') {
        new GloryModalForm();
    } else {
        if (typeof GloryAjax !== 'function') console.error('GloryModalForm could not initialize: GloryAjax function is not defined.');
        if (typeof window.GloryModalService === 'undefined') console.error('GloryModalForm could not initialize: GloryModalService is not defined.');
    }
});